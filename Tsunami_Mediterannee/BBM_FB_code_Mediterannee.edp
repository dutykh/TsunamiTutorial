/*
   Propagation of a Tsunami wave in the Mediterranean sea with a flat bottom.
   
   to run this script : FreeFem++ BBM_FB_code_Mediterannee.edp -ns -v 0
   
   WARNING : don't forget to generate the mesh from the folder "mesh_generation"
   that you wan't to use in this script
   
   Copyright (C) 2020 Georges SADAKA and Denys Dutykh

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.

   --------------------------------------------------------------------------------------------
   The main file for propagation of a Tsunami wave in the Mediterranean sea with a flat bottom.
   --------------------------------------------------------------------------------------------
   Author 1: Georges SADAKA, LMRS -- University of Rouen
   Author 2: Denys Dutykh, CNRS -- LAMA, USMB          
   E-mail 1: Georges.SADAKA@univ-rouen.fr                  
   E-mail 2: Denys.Dutykh@univ-smb.fr   
   Web 1:  http://georges-sadaka.fr/ 
   Web 2:  http://www.denys-dutykh.com/
   Blog 2:   http://dutykh.github.io/    
   GitHub 1: https://github.com/GeorgesSadaka/
   GitHub 2: https://github.com/dutykh/  
   -----------------------------------------------------------------------
   Distributed under GNU General Public License      
   --------------------------------------------------
*/

verbosity=0;
load "shell"
load "medit"
load "isoline"
bool output=true;
bool adapt=true;
bool save=true;
string method="Adapt_GS"; // Adapt_GS or Adapt_FF or Full
int Nplot=10,Nsave=100;
string DIRSAVE="Tsu_Medit_"+method;
if(method=="Full") adapt=false;
if(!adapt) DIRSAVE="Tsu_Medit_Full";
mkdir(DIRSAVE);

if(adapt & method=="Adapt_GS") include "../Common_files/adapt_GS.edp"
real s0=time(),s0adapt;
macro grad(u)[dx(u),dy(u)]//
macro div(u,v)(dx(u)+dy(v))//
macro F(e,u,v,t)(((D+e) * div(u,v) + ([DX,DY]+grad(e))'*[u,v])*t)//
macro G(e,u,v,t)((dx(e)+dx(u)*(u)+dx(v)*(v))*t)//
macro H(e,u,v,t)((dy(u)*(u)+dy(v)*(v)+dy(e))*t)//
int op=0;
real theta2=2./3.,mu=(4.-6.*theta2)/(3.*(1.-theta2)), nu=0.;//BBM_BBM
real a=.5*(theta2-1./3.)*nu, b=.5*(theta2-1./3.)*(1.-nu), c=.5*(1-theta2)*mu, d=.5*(1-theta2)*(1.-mu);
real t,dt,T=1000.;
real scale=1.21767;
mesh Th("../Common_files/Mediterannee_eps_1_alpha_1_Dx_1.5.msh");
real L = 20.;
real W = 10.;
real eps=1.e-16;
real x0 = 2390.*scale;//2410.*scale;
real y0 = 590.*scale;//610.*scale;
real iso=0.05;
real erradapt=1.e-7;
real smooth = .005;
if(adapt & method=="Adapt_GS") cout<<"iso="<<iso<<", erradapt="<<erradapt<<", smooth="<<smooth<<endl;
mesh Thinit=Th;
fespace Vhinit(Thinit,P0);
Vhinit hT=hTriangle;
real Dx=(hT[].min+hT[].max)/2.;
fespace Wh(Th,P2);
real aa=x0-5.*W,bb=x0+4.*W,cc=y0-1.5*L,dd=y0+2.5*L;
if(adapt & method=="Adapt_GS") Th=trunc(Thinit,(1.*(x <= bb & x >= aa) *(y <= dd & y >= cc))>erradapt,label=0);
Wh w,uP0;
{   real delta = 7.0*pi/180.0;
   real phi = -(0.0 - 90.0)*pi/180.0;
   real rake = 90.0*pi/180.0;
   real d = 10. + W*sin(delta);
   real slip = 2.5;
   real E=9.5e9;//Young
   real nu=0.27;//Poisson
   real mu = E/(2.*(1.+nu));
   real lambda = E*nu/((1.+nu)*(1.-2.*nu));
   include "../Common_files/OkadaSol.edp"
   w=w/1.e3;
   for (int i=0;i<w.n;i++){
      if (abs(w[](i))>=5.e-5)
         w[](i)=w[](i);
      else
         w[](i)=0.;
   }
   {   ofstream file("w.txt");   file << w[];   }
}
{   ifstream file("w.txt");   file >> w[];   }
fespace Vh(Th,[P1,P1,P1]);
Vh [eta, u1, u2],[eta0,u0,v0]=[w,0.,0.], [etaex, uex, vex],[te,tu,tv];
Vh [eta0pk1, u0pk1, v0pk1], [etak1, uk1, vk1], [etak2, uk2, vk2];
Wh MAX=0.,MIN=0.,Peta0=eta0;
dt=.1;
{
   ofstream mat(DIRSAVE+"/Gauge_Tsunami_Java_Pas_"+method+".m");
   mat<<"#Time_gauge1_gauge2_cputime_adapttime_Nt_Ndof_INV0"<<endl;
}
real gauge1,gauge2,INV0;
func g=0.;
Wh D, D2, DX, DY, tD;
D=1.5;DX=0.;DY=0.;
D2=D^2;
int m=0, km = 0, nadapt = 1;
for (t=dt;t<=T;t+=dt) {
   if ( !(m % 10) & save ){
      Peta0=eta0;
      for (int i=0;i<Th.nt;i++){ 
         for (int j=0; j < 3; j++){
            MAX[][Wh(i,j)]=max(MAX[][Wh(i,j)],Peta0[][Wh(i,j)]);
         }
         MAX[][Wh(i,0)]=max(MAX[][Wh(i,0)],Peta0[][Wh(i,0)]);
      }
   }
   if ( ( (!(m % 100) ) & (m>=0) ) & adapt ){
      s0adapt = time();
      uP0=eta0+u0+v0;
      if(output){
         plot(uP0,fill=true,dim=2,value=true,wait=0.,cmm="uP0"+uP0[].max+"min"+uP0[].min);
         Peta0=(abs(uP0)>erradapt);
         plot(Peta0,fill=true,dim=2,value=true,wait=0.,cmm="Peta0");
      }
      if(method=="Adapt_GS"){
         mesh Thp=Th;
         { AdaptGS(Thp,uP0,erradapt,iso,smooth,50.,Thinit,false,0.); }
         fespace Whp(Thp,P1);
         Wh peta0=eta0,pu0=u0,pv0=v0,pMAX=MAX;
         Whp Dp,MINp,MAXp,eta0p,u0p,v0p;
         matrix BWinterp=interpolate(Wh,Whp,inside=true);
         BWinterp=BWinterp';
         eta0p[]=BWinterp*peta0[];
         u0p[]=BWinterp*pu0[];
         v0p[]=BWinterp*pv0[];
         if(save) MAXp[]=BWinterp*pMAX[];
         Th=Thp;
         [eta0,u0,v0]=[eta0p,u0p,v0p];
         if(save) MAX=MAXp;
      }
      if(method=="Adapt_FF"){
         Th=adaptmesh(Th,uP0,err=1.e-2,hmin=Dx,iso=true,nbvx=1e8);
         [eta0,u0,v0]=[eta0,u0,v0];
         if(save) MAX=MAX;
      }
      D=D;   D2 = D^2;DX = dx(D);DY = dy(D);
      s0adapt = time()-s0adapt;
      op=0;
   }
   Peta0 = eta0;
   gauge1=Peta0(2350.*scale,550.*scale);
   gauge2=Peta0(2104.*scale,665.*scale);
   INV0=int2d(Th)(Peta0);
   { ofstream mat(DIRSAVE+"/Gauge_Tsunami_Mediterrannee_"+method+".m",append);
      mat<<t<<" "<<gauge1<<" "<<gauge2<<" "<<time()-s0<<" "<<s0adapt<<" "<<Th.nt<<" "<<Wh.ndof<<" "<<INV0<<endl;
   }
   if(!(m % 10)) cout<<"time = "<<t<<", gauge1 = "<<gauge1<<", gauge2 = "<<gauge2<<", cputime = "<<time()-s0<<", cpuadatp = "<<s0adapt<<", Th.nt = "<<Th.nt<<", ndof = "<<Wh.ndof<<", INV0 = "<<INV0<<endl;
   if(save && !(m % Nsave)){
      savemesh(Th,DIRSAVE+"/Tsunami_mediterannee_"+method+"_BBM_MAX."+(10000000+km)+".mesh");
      savesol(DIRSAVE+"/Tsunami_mediterannee_"+method+"_BBM_MAX."+(10000000+km)+".sol",Th,MAX);
      savemesh(Th,DIRSAVE+"/Tsunami_mediterannee_"+method+"_BBM_SOL."+(10000000+km)+".mesh");
      savesol(DIRSAVE+"/Tsunami_mediterannee_"+method+"_BBM_SOL."+(10000000+km)+".sol",Th,Peta0);
      km++;
   }
   if(output && !(m % Nplot)) plot(eta0,fill=true,value=true,dim=2,wait=0.,cmm="t= "+t);   
   include "BBM_VB_RK2_problem_mediterannee.edp"
   op=1;
   m++;
}
cout << " CPU time = " << time()-s0 << endl;